package com.sentrana.usermanagement.authentication

import java.sql.Timestamp

import scala.util.Random
import scala.util.matching.Regex

import play.api.Play
import play.api.Play.current
import play.api.mvc.Request

import com.sentrana.appshell.utils.RegexUtils._
import com.sentrana.appshell.utils.{ ConfigurationUtil, DateTimeUtil }
import com.sentrana.usermanagement.datacontract._
import com.sentrana.usermanagement.domain.document._

/**
 * Created by szhao on 1/23/14.
 */

object SecurityManager {
  val DefaultSessionTimeout = 60
  val DefaultMaxPasswordsToCheck = 5

  val sessionTimeout = Play.configuration.getInt("SessionTimeoutMinutes").getOrElse(DefaultSessionTimeout)
  val userSessionManager = AppSessionManager[UserSession](sessionTimeout)
  val userSessionManagerInMemory = InMemorySessionManager[UserSession](sessionTimeout)
  userSessionManager.createCleanUpTimer(sessionTimeout)

  /**
   * A wrapper method for salted password hashing with PBKDF2-SHA1.
   * @param password User password
   * @return Encrypted password string
   */
  def createPasswordHash(password: String): String = {
    PasswordHash.create(password).toBase64String
  }

  /**
   * During this transition period, we will also support plain text password.
   * @param dbPassword password stored in database
   * @param password Password text passed in
   * @return Whether password is different from dbPassword
   */
  def checkPassword(dbPassword: String, password: String): Boolean = {
    try {
      PasswordHash.parse(dbPassword).checkPassword(password)
    }
    catch {
      case e: NumberFormatException => password == dbPassword
      case _: Throwable             => false
    }
  }

  def changeAutoGeneratedPassword(user: User, passwordInfo: ChangeAutoGeneratedPassword, resetRequest: PasswordResetRequest): Unit = {
    if (resetRequest.securityCode != passwordInfo.securityCode) {
      throw new PasswordResetInvalidSecurityCodeException(user.userName)
    }
    if (isPasswordResetLinkExpired(resetRequest)) {
      UMDataServices.removePasswordResetRequest(resetRequest.id)
      throw new PasswordResetLinkExpiredException(resetRequest.requestToken)
    }
    changePasswordWithPolicy(user, passwordInfo.newPassword)
    UMDataServices.removePasswordResetRequest(resetRequest.id)
  }

  def isPasswordResetLinkExpired(resetRequest: PasswordResetRequest): Boolean = {
    val timeOut = ConfigurationUtil.getAppSettingValue("PasswordResetLinkTimeout").toInt
    val hourDifference = DateTimeUtil.getTimeDifference(resetRequest.requestTime, "hour")
    hourDifference > timeOut
  }

  def changePasswordWithPolicy(user: User, newPassword: String): Unit = {
    validatePasswordChange(user, newPassword)
    val userPasswordHistory = UserPasswordHistory(
      id          = UMDataServices.getObjectId,
      userId      = user.id,
      oldPassword = user.password,
      newPassword = createPasswordHash(newPassword),
      dateCreated = new Timestamp(System.currentTimeMillis)
    )
    UMDataServices().saveDocument(userPasswordHistory)
    try {
      changePassword(user, newPassword)
    }
    catch {
      case ex: Throwable =>
        UMDataServices().removeDocuments[UserPasswordHistory](Map("id" -> userPasswordHistory.id))
        throw ex
    }
  }

  private def validatePasswordChange(user: User, newPassword: String): Unit = {
    if (newPassword.isEmpty) {
      throw new EmptyPasswordException(user.userName)
    }
    if (!isValidPasswordFormat(newPassword)) {
      throw new InvalidPasswordFormatException(user.userName)
    }
    if (isPasswordPreviouslyUsed(user, newPassword)) {
      throw new PreviouslyUsedPasswordException(user.userName)
    }
  }

  private def isPasswordPreviouslyUsed(user: User, newPassword: String): Boolean = {
    val maxPasswordsToCheck = Play.configuration.getInt("um.password.times.not.allowed")
      .getOrElse(DefaultMaxPasswordsToCheck)
    val passwordsToCheck = UMDataServices().getDocuments[UserPasswordHistory](Map("userId" -> user.id))
      .sortBy{ _.dateCreated.getTime }(Ordering[Long].reverse)
      .take(maxPasswordsToCheck)
      .map{ _.newPassword }

    passwordsToCheck.exists{ oldPassword =>
      PasswordHash.parse(oldPassword).checkPassword(newPassword)
    }
  }

  private def isValidPasswordFormat(newPassword: String): Boolean = {
    val passwordRegex = new Regex(ConfigurationUtil.getAppSettingValue("PasswordRegExp"))
    passwordRegex.matches(newPassword)
  }

  /**
   * Update user password in the encrypted format.
   * @param user User object
   * @param newPassword New password passed back
   * @return success or not
   */
  private def changePassword(user: User, newPassword: String): Unit = {
    val updatedUser = user.copy(password = createPasswordHash(newPassword))
    val organization = user.organization
    val users = organization.users.filterNot(_.id == updatedUser.id)
    val newOrg = organization.copy(users = users :+ updatedUser)
    UMDataServices().updateDocument(Map("id" -> newOrg.id), newOrg)
  }

  def createDummySession(login: String, connectionString: String): UserSession = {
    val session = new UserSession(
      User("0", "0", login, "", "", "", None, null, 0, 0, None, Seq(), Seq(), Seq(), ""), null, null
    )

    session
  }

  def createPasswordResetRequest(user: User): PasswordResetRequest = {
    UMDataServices().removeDocuments[PasswordResetRequest](Map("userId" -> user.id))
    val request = PasswordResetRequest(
      requestStatus = true,
      requestToken  = getPasswordResetToken,
      securityCode  = getPasswordResetSecurityCode,
      userId        = user.id,
      id            = UMDataServices.getObjectId
    )
    UMDataServices().saveDocument[PasswordResetRequest](request)
    request
  }

  def getPasswordResetSecurityCode: String = {
    //Create 8 digit random number
    (new Random().nextInt(89999999) + 10000000).toString
  }

  def getPasswordResetToken: String = {
    Guid[PasswordResetRequest].random.id
  }

  /**
   * This is the main interface method that would be used by other application.
   * It creates a UserSession object by validating the login and password combination.
   * @param userName Unique User ID
   * @param password User password
   * @return UserSession object
   */
  def createSession[A](userName: String, password: String)(implicit request: Request[A]): UserSession = {
    val userOption = UMDataServices.getActiveUser("userName", userName)
    val user = userOption.filter(x => checkPassword(x.password, password)).getOrElse {
      if (userOption.nonEmpty) {
        // Save login failure count
        saveUserLoginRecord(userOption.get, result = false)
      }
      throw new InvalidCredentialsException(userName)
    }

    // Save login success count
    saveUserLoginRecord(user, result = true)

    val session = new UserSession(user, user.organization, user.organization.applications.toList)
    saveSession(session)
    session
  }

  def saveUserLoginRecord[A](user: User, result: Boolean)(implicit request: Request[A]): Unit = {
    val ulr = UserLoginRecord(
      UMDataServices.getObjectId,
      new Timestamp(System.currentTimeMillis),
      request.remoteAddress,
      result,
      user.id
    )
    UMDataServices().saveDocument(ulr)
  }

  def createSession(userName: String, sessionToken: Guid[Session]): UserSession = {
    val currentUser = getCurrentUser(userName)
    new UserSession(currentUser, currentUser.organization, currentUser.organization.applications.toList, sessionToken)
  }

  def createSession(userName: String): UserSession = {
    val currentUser = getCurrentUser(userName)
    new UserSession(currentUser, currentUser.organization, currentUser.organization.applications.toList)
  }

  def getCurrentUser(userName: String): User = {
    UMDataServices.getActiveUser("userName", userName).getOrElse(
      throw new UserNameNotFoundException(userName)
    )
  }

  /**
   * This is the helper method for use to get the user session object by passing the request object.
   * @param request
   * @return
   */
  def getSession[A](request: Request[A]): UserSession = {
    val token = getSessionToken(request) getOrElse {
      throw new NoSessionTokenException
    }
    getSession(token) filter { _.isOpen } getOrElse {
      throw new InvalidSessionException(token)
    }
  }

  def getSession(sessionToken: String): Option[UserSession] = {
    val token: Guid[Session] = new Guid(sessionToken)
    userSessionManager getSession token filter { _.isOpen }
  }

  private def getSessionToken[A](request: Request[A]): Option[String] =
    request.getQueryString("sessionid")
      .orElse(request.headers.get("sessionID"))
      .orElse(request.headers.get("SessionID"))
      .orElse(request.cookies.get("sessionId").map{ _.value })

  private def getSessionFromMemory(sessionToken: String): UserSession = {
    val token: Guid[Session] = new Guid(sessionToken)
    userSessionManagerInMemory getSession token getOrElse {
      throw new InvalidSessionException(sessionToken)
    }
  }

  def saveSession(session: UserSession): Unit = {
    userSessionManager.saveSession(session)
  }

  /**
   * Closes the session associated with the specified session token.
   * Note: This method always returns cleanly, whether or not the given session was in fact closed.
   * @param sessionToken A token identifying the session to close.
   */
  def closeSession(sessionToken: String): Unit = {
    // Clean up caching objects
    for (session <- getSession(sessionToken); key <- session.cacheKeyList) {
      session.cache.remove(key)
    }

    val token: Guid[Session] = new Guid(sessionToken)
    userSessionManager.closeSession(token)
  }

  def closeInMemorySession(sessionToken: String): Unit = {
    // Clean up caching objects
    val session = getSessionFromMemory(sessionToken)
    session.cacheKeyList.foreach{ session.cache.remove }

    val token: Guid[Session] = new Guid(sessionToken)
    userSessionManagerInMemory.closeSession(token)
  }

  private def hasRole(user: User, appRole: EnumApplicationRoles.Value) =
    user.appRoles.exists{ _.id == appRole.toString }

  private def isAdmin(user: User) =
    hasRole(user, EnumApplicationRoles.UNRESTRICTED_USER_ADMIN)

  private def isAdminOrValidOrg(user: User, orgId: String) =
    user.organizationId == orgId || isAdmin(user)

  def requireAdmin(user: User): Unit = {
    checkAccess(user)(isAdmin)
  }

  def requireAdminOrValidOrg(user: User, orgId: String): Unit = {
    checkAccess(user)(isAdminOrValidOrg(_, orgId))
  }

  def requireRole(user: User, appRole: EnumApplicationRoles.Value): Unit = {
    checkAccess(user)(hasRole(_, appRole))
  }

  def checkAccess(user: User)(accessCheck: User => Boolean): Unit = {
    if (!accessCheck(user)) throw new UnauthorizedServiceAccessException(user.userName)
  }
}
